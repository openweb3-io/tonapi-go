/*
REST api to TON blockchain explorer

Provide access to indexed TON blockchain

API version: 2.0.0
Contact: support@tonkeeper.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tonapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the BlockchainRawAccount type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &BlockchainRawAccount{}

// BlockchainRawAccount struct for BlockchainRawAccount
type BlockchainRawAccount struct {
	Address string `json:"address"`
	Balance int64 `json:"balance"`
	ExtraBalance *map[string]string `json:"extra_balance,omitempty"`
	Code *string `json:"code,omitempty"`
	Data *string `json:"data,omitempty"`
	LastTransactionLt int64 `json:"last_transaction_lt"`
	LastTransactionHash *string `json:"last_transaction_hash,omitempty"`
	FrozenHash *string `json:"frozen_hash,omitempty"`
	Status AccountStatus `json:"status"`
	Storage AccountStorageInfo `json:"storage"`
	Libraries []BlockchainRawAccountLibrariesInner `json:"libraries,omitempty"`
}

type _BlockchainRawAccount BlockchainRawAccount

// NewBlockchainRawAccount instantiates a new BlockchainRawAccount object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewBlockchainRawAccount(address string, balance int64, lastTransactionLt int64, status AccountStatus, storage AccountStorageInfo) *BlockchainRawAccount {
	this := BlockchainRawAccount{}
	this.Address = address
	this.Balance = balance
	this.LastTransactionLt = lastTransactionLt
	this.Status = status
	this.Storage = storage
	return &this
}

// NewBlockchainRawAccountWithDefaults instantiates a new BlockchainRawAccount object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewBlockchainRawAccountWithDefaults() *BlockchainRawAccount {
	this := BlockchainRawAccount{}
	return &this
}

// GetAddress returns the Address field value
func (o *BlockchainRawAccount) GetAddress() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Address
}

// GetAddressOk returns a tuple with the Address field value
// and a boolean to check if the value has been set.
func (o *BlockchainRawAccount) GetAddressOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Address, true
}

// SetAddress sets field value
func (o *BlockchainRawAccount) SetAddress(v string) {
	o.Address = v
}

// GetBalance returns the Balance field value
func (o *BlockchainRawAccount) GetBalance() int64 {
	if o == nil {
		var ret int64
		return ret
	}

	return o.Balance
}

// GetBalanceOk returns a tuple with the Balance field value
// and a boolean to check if the value has been set.
func (o *BlockchainRawAccount) GetBalanceOk() (*int64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Balance, true
}

// SetBalance sets field value
func (o *BlockchainRawAccount) SetBalance(v int64) {
	o.Balance = v
}

// GetExtraBalance returns the ExtraBalance field value if set, zero value otherwise.
func (o *BlockchainRawAccount) GetExtraBalance() map[string]string {
	if o == nil || IsNil(o.ExtraBalance) {
		var ret map[string]string
		return ret
	}
	return *o.ExtraBalance
}

// GetExtraBalanceOk returns a tuple with the ExtraBalance field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *BlockchainRawAccount) GetExtraBalanceOk() (*map[string]string, bool) {
	if o == nil || IsNil(o.ExtraBalance) {
		return nil, false
	}
	return o.ExtraBalance, true
}

// HasExtraBalance returns a boolean if a field has been set.
func (o *BlockchainRawAccount) HasExtraBalance() bool {
	if o != nil && !IsNil(o.ExtraBalance) {
		return true
	}

	return false
}

// SetExtraBalance gets a reference to the given map[string]string and assigns it to the ExtraBalance field.
func (o *BlockchainRawAccount) SetExtraBalance(v map[string]string) {
	o.ExtraBalance = &v
}

// GetCode returns the Code field value if set, zero value otherwise.
func (o *BlockchainRawAccount) GetCode() string {
	if o == nil || IsNil(o.Code) {
		var ret string
		return ret
	}
	return *o.Code
}

// GetCodeOk returns a tuple with the Code field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *BlockchainRawAccount) GetCodeOk() (*string, bool) {
	if o == nil || IsNil(o.Code) {
		return nil, false
	}
	return o.Code, true
}

// HasCode returns a boolean if a field has been set.
func (o *BlockchainRawAccount) HasCode() bool {
	if o != nil && !IsNil(o.Code) {
		return true
	}

	return false
}

// SetCode gets a reference to the given string and assigns it to the Code field.
func (o *BlockchainRawAccount) SetCode(v string) {
	o.Code = &v
}

// GetData returns the Data field value if set, zero value otherwise.
func (o *BlockchainRawAccount) GetData() string {
	if o == nil || IsNil(o.Data) {
		var ret string
		return ret
	}
	return *o.Data
}

// GetDataOk returns a tuple with the Data field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *BlockchainRawAccount) GetDataOk() (*string, bool) {
	if o == nil || IsNil(o.Data) {
		return nil, false
	}
	return o.Data, true
}

// HasData returns a boolean if a field has been set.
func (o *BlockchainRawAccount) HasData() bool {
	if o != nil && !IsNil(o.Data) {
		return true
	}

	return false
}

// SetData gets a reference to the given string and assigns it to the Data field.
func (o *BlockchainRawAccount) SetData(v string) {
	o.Data = &v
}

// GetLastTransactionLt returns the LastTransactionLt field value
func (o *BlockchainRawAccount) GetLastTransactionLt() int64 {
	if o == nil {
		var ret int64
		return ret
	}

	return o.LastTransactionLt
}

// GetLastTransactionLtOk returns a tuple with the LastTransactionLt field value
// and a boolean to check if the value has been set.
func (o *BlockchainRawAccount) GetLastTransactionLtOk() (*int64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.LastTransactionLt, true
}

// SetLastTransactionLt sets field value
func (o *BlockchainRawAccount) SetLastTransactionLt(v int64) {
	o.LastTransactionLt = v
}

// GetLastTransactionHash returns the LastTransactionHash field value if set, zero value otherwise.
func (o *BlockchainRawAccount) GetLastTransactionHash() string {
	if o == nil || IsNil(o.LastTransactionHash) {
		var ret string
		return ret
	}
	return *o.LastTransactionHash
}

// GetLastTransactionHashOk returns a tuple with the LastTransactionHash field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *BlockchainRawAccount) GetLastTransactionHashOk() (*string, bool) {
	if o == nil || IsNil(o.LastTransactionHash) {
		return nil, false
	}
	return o.LastTransactionHash, true
}

// HasLastTransactionHash returns a boolean if a field has been set.
func (o *BlockchainRawAccount) HasLastTransactionHash() bool {
	if o != nil && !IsNil(o.LastTransactionHash) {
		return true
	}

	return false
}

// SetLastTransactionHash gets a reference to the given string and assigns it to the LastTransactionHash field.
func (o *BlockchainRawAccount) SetLastTransactionHash(v string) {
	o.LastTransactionHash = &v
}

// GetFrozenHash returns the FrozenHash field value if set, zero value otherwise.
func (o *BlockchainRawAccount) GetFrozenHash() string {
	if o == nil || IsNil(o.FrozenHash) {
		var ret string
		return ret
	}
	return *o.FrozenHash
}

// GetFrozenHashOk returns a tuple with the FrozenHash field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *BlockchainRawAccount) GetFrozenHashOk() (*string, bool) {
	if o == nil || IsNil(o.FrozenHash) {
		return nil, false
	}
	return o.FrozenHash, true
}

// HasFrozenHash returns a boolean if a field has been set.
func (o *BlockchainRawAccount) HasFrozenHash() bool {
	if o != nil && !IsNil(o.FrozenHash) {
		return true
	}

	return false
}

// SetFrozenHash gets a reference to the given string and assigns it to the FrozenHash field.
func (o *BlockchainRawAccount) SetFrozenHash(v string) {
	o.FrozenHash = &v
}

// GetStatus returns the Status field value
func (o *BlockchainRawAccount) GetStatus() AccountStatus {
	if o == nil {
		var ret AccountStatus
		return ret
	}

	return o.Status
}

// GetStatusOk returns a tuple with the Status field value
// and a boolean to check if the value has been set.
func (o *BlockchainRawAccount) GetStatusOk() (*AccountStatus, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Status, true
}

// SetStatus sets field value
func (o *BlockchainRawAccount) SetStatus(v AccountStatus) {
	o.Status = v
}

// GetStorage returns the Storage field value
func (o *BlockchainRawAccount) GetStorage() AccountStorageInfo {
	if o == nil {
		var ret AccountStorageInfo
		return ret
	}

	return o.Storage
}

// GetStorageOk returns a tuple with the Storage field value
// and a boolean to check if the value has been set.
func (o *BlockchainRawAccount) GetStorageOk() (*AccountStorageInfo, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Storage, true
}

// SetStorage sets field value
func (o *BlockchainRawAccount) SetStorage(v AccountStorageInfo) {
	o.Storage = v
}

// GetLibraries returns the Libraries field value if set, zero value otherwise.
func (o *BlockchainRawAccount) GetLibraries() []BlockchainRawAccountLibrariesInner {
	if o == nil || IsNil(o.Libraries) {
		var ret []BlockchainRawAccountLibrariesInner
		return ret
	}
	return o.Libraries
}

// GetLibrariesOk returns a tuple with the Libraries field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *BlockchainRawAccount) GetLibrariesOk() ([]BlockchainRawAccountLibrariesInner, bool) {
	if o == nil || IsNil(o.Libraries) {
		return nil, false
	}
	return o.Libraries, true
}

// HasLibraries returns a boolean if a field has been set.
func (o *BlockchainRawAccount) HasLibraries() bool {
	if o != nil && !IsNil(o.Libraries) {
		return true
	}

	return false
}

// SetLibraries gets a reference to the given []BlockchainRawAccountLibrariesInner and assigns it to the Libraries field.
func (o *BlockchainRawAccount) SetLibraries(v []BlockchainRawAccountLibrariesInner) {
	o.Libraries = v
}

func (o BlockchainRawAccount) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o BlockchainRawAccount) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["address"] = o.Address
	toSerialize["balance"] = o.Balance
	if !IsNil(o.ExtraBalance) {
		toSerialize["extra_balance"] = o.ExtraBalance
	}
	if !IsNil(o.Code) {
		toSerialize["code"] = o.Code
	}
	if !IsNil(o.Data) {
		toSerialize["data"] = o.Data
	}
	toSerialize["last_transaction_lt"] = o.LastTransactionLt
	if !IsNil(o.LastTransactionHash) {
		toSerialize["last_transaction_hash"] = o.LastTransactionHash
	}
	if !IsNil(o.FrozenHash) {
		toSerialize["frozen_hash"] = o.FrozenHash
	}
	toSerialize["status"] = o.Status
	toSerialize["storage"] = o.Storage
	if !IsNil(o.Libraries) {
		toSerialize["libraries"] = o.Libraries
	}
	return toSerialize, nil
}

func (o *BlockchainRawAccount) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"address",
		"balance",
		"last_transaction_lt",
		"status",
		"storage",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varBlockchainRawAccount := _BlockchainRawAccount{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varBlockchainRawAccount)

	if err != nil {
		return err
	}

	*o = BlockchainRawAccount(varBlockchainRawAccount)

	return err
}

type NullableBlockchainRawAccount struct {
	value *BlockchainRawAccount
	isSet bool
}

func (v NullableBlockchainRawAccount) Get() *BlockchainRawAccount {
	return v.value
}

func (v *NullableBlockchainRawAccount) Set(val *BlockchainRawAccount) {
	v.value = val
	v.isSet = true
}

func (v NullableBlockchainRawAccount) IsSet() bool {
	return v.isSet
}

func (v *NullableBlockchainRawAccount) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableBlockchainRawAccount(val *BlockchainRawAccount) *NullableBlockchainRawAccount {
	return &NullableBlockchainRawAccount{value: val, isSet: true}
}

func (v NullableBlockchainRawAccount) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableBlockchainRawAccount) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


