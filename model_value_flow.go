/*
REST api to TON blockchain explorer

Provide access to indexed TON blockchain

API version: 2.0.0
Contact: support@tonkeeper.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tonapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the ValueFlow type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &ValueFlow{}

// ValueFlow struct for ValueFlow
type ValueFlow struct {
	Account AccountAddress `json:"account"`
	Ton int64 `json:"ton"`
	Fees int64 `json:"fees"`
	Jettons []ValueFlowJettonsInner `json:"jettons,omitempty"`
}

type _ValueFlow ValueFlow

// NewValueFlow instantiates a new ValueFlow object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewValueFlow(account AccountAddress, ton int64, fees int64) *ValueFlow {
	this := ValueFlow{}
	this.Account = account
	this.Ton = ton
	this.Fees = fees
	return &this
}

// NewValueFlowWithDefaults instantiates a new ValueFlow object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewValueFlowWithDefaults() *ValueFlow {
	this := ValueFlow{}
	return &this
}

// GetAccount returns the Account field value
func (o *ValueFlow) GetAccount() AccountAddress {
	if o == nil {
		var ret AccountAddress
		return ret
	}

	return o.Account
}

// GetAccountOk returns a tuple with the Account field value
// and a boolean to check if the value has been set.
func (o *ValueFlow) GetAccountOk() (*AccountAddress, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Account, true
}

// SetAccount sets field value
func (o *ValueFlow) SetAccount(v AccountAddress) {
	o.Account = v
}

// GetTon returns the Ton field value
func (o *ValueFlow) GetTon() int64 {
	if o == nil {
		var ret int64
		return ret
	}

	return o.Ton
}

// GetTonOk returns a tuple with the Ton field value
// and a boolean to check if the value has been set.
func (o *ValueFlow) GetTonOk() (*int64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Ton, true
}

// SetTon sets field value
func (o *ValueFlow) SetTon(v int64) {
	o.Ton = v
}

// GetFees returns the Fees field value
func (o *ValueFlow) GetFees() int64 {
	if o == nil {
		var ret int64
		return ret
	}

	return o.Fees
}

// GetFeesOk returns a tuple with the Fees field value
// and a boolean to check if the value has been set.
func (o *ValueFlow) GetFeesOk() (*int64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Fees, true
}

// SetFees sets field value
func (o *ValueFlow) SetFees(v int64) {
	o.Fees = v
}

// GetJettons returns the Jettons field value if set, zero value otherwise.
func (o *ValueFlow) GetJettons() []ValueFlowJettonsInner {
	if o == nil || IsNil(o.Jettons) {
		var ret []ValueFlowJettonsInner
		return ret
	}
	return o.Jettons
}

// GetJettonsOk returns a tuple with the Jettons field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ValueFlow) GetJettonsOk() ([]ValueFlowJettonsInner, bool) {
	if o == nil || IsNil(o.Jettons) {
		return nil, false
	}
	return o.Jettons, true
}

// HasJettons returns a boolean if a field has been set.
func (o *ValueFlow) HasJettons() bool {
	if o != nil && !IsNil(o.Jettons) {
		return true
	}

	return false
}

// SetJettons gets a reference to the given []ValueFlowJettonsInner and assigns it to the Jettons field.
func (o *ValueFlow) SetJettons(v []ValueFlowJettonsInner) {
	o.Jettons = v
}

func (o ValueFlow) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o ValueFlow) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["account"] = o.Account
	toSerialize["ton"] = o.Ton
	toSerialize["fees"] = o.Fees
	if !IsNil(o.Jettons) {
		toSerialize["jettons"] = o.Jettons
	}
	return toSerialize, nil
}

func (o *ValueFlow) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"account",
		"ton",
		"fees",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varValueFlow := _ValueFlow{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varValueFlow)

	if err != nil {
		return err
	}

	*o = ValueFlow(varValueFlow)

	return err
}

type NullableValueFlow struct {
	value *ValueFlow
	isSet bool
}

func (v NullableValueFlow) Get() *ValueFlow {
	return v.value
}

func (v *NullableValueFlow) Set(val *ValueFlow) {
	v.value = val
	v.isSet = true
}

func (v NullableValueFlow) IsSet() bool {
	return v.isSet
}

func (v *NullableValueFlow) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableValueFlow(val *ValueFlow) *NullableValueFlow {
	return &NullableValueFlow{value: val, isSet: true}
}

func (v NullableValueFlow) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableValueFlow) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


