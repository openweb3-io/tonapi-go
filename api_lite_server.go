/*
REST api to TON blockchain explorer

Provide access to indexed TON blockchain

API version: 2.0.0
Contact: support@tonkeeper.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tonapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// LiteServerAPIService LiteServerAPI service
type LiteServerAPIService service

type ApiGetAllRawShardsInfoRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	blockId string
}

func (r ApiGetAllRawShardsInfoRequest) Execute() (*GetAllRawShardsInfo200Response, *http.Response, error) {
	return r.ApiService.GetAllRawShardsInfoExecute(r)
}

/*
GetAllRawShardsInfo Method for GetAllRawShardsInfo

Get all raw shards info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
 @return ApiGetAllRawShardsInfoRequest
*/
func (a *LiteServerAPIService) GetAllRawShardsInfo(ctx context.Context, blockId string) ApiGetAllRawShardsInfoRequest {
	return ApiGetAllRawShardsInfoRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return GetAllRawShardsInfo200Response
func (a *LiteServerAPIService) GetAllRawShardsInfoExecute(r ApiGetAllRawShardsInfoRequest) (*GetAllRawShardsInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllRawShardsInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetAllRawShardsInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_all_shards_info/{block_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_id"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOutMsgQueueSizesRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
}

func (r ApiGetOutMsgQueueSizesRequest) Execute() (*GetOutMsgQueueSizes200Response, *http.Response, error) {
	return r.ApiService.GetOutMsgQueueSizesExecute(r)
}

/*
GetOutMsgQueueSizes Method for GetOutMsgQueueSizes

Get out msg queue sizes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOutMsgQueueSizesRequest
*/
func (a *LiteServerAPIService) GetOutMsgQueueSizes(ctx context.Context) ApiGetOutMsgQueueSizesRequest {
	return ApiGetOutMsgQueueSizesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetOutMsgQueueSizes200Response
func (a *LiteServerAPIService) GetOutMsgQueueSizesExecute(r ApiGetOutMsgQueueSizesRequest) (*GetOutMsgQueueSizes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOutMsgQueueSizes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetOutMsgQueueSizes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_out_msg_queue_sizes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawAccountStateRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	accountId string
	targetBlock *string
}

// target block: (workchain,shard,seqno,root_hash,file_hash)
func (r ApiGetRawAccountStateRequest) TargetBlock(targetBlock string) ApiGetRawAccountStateRequest {
	r.targetBlock = &targetBlock
	return r
}

func (r ApiGetRawAccountStateRequest) Execute() (*GetRawAccountState200Response, *http.Response, error) {
	return r.ApiService.GetRawAccountStateExecute(r)
}

/*
GetRawAccountState Method for GetRawAccountState

Get raw account state

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId account ID
 @return ApiGetRawAccountStateRequest
*/
func (a *LiteServerAPIService) GetRawAccountState(ctx context.Context, accountId string) ApiGetRawAccountStateRequest {
	return ApiGetRawAccountStateRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return GetRawAccountState200Response
func (a *LiteServerAPIService) GetRawAccountStateExecute(r ApiGetRawAccountStateRequest) (*GetRawAccountState200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawAccountState200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawAccountState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_account_state/{account_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.targetBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_block", r.targetBlock, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawBlockProofRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	knownBlock *string
	mode *int32
	targetBlock *string
}

// known block: (workchain,shard,seqno,root_hash,file_hash)
func (r ApiGetRawBlockProofRequest) KnownBlock(knownBlock string) ApiGetRawBlockProofRequest {
	r.knownBlock = &knownBlock
	return r
}

// mode
func (r ApiGetRawBlockProofRequest) Mode(mode int32) ApiGetRawBlockProofRequest {
	r.mode = &mode
	return r
}

// target block: (workchain,shard,seqno,root_hash,file_hash)
func (r ApiGetRawBlockProofRequest) TargetBlock(targetBlock string) ApiGetRawBlockProofRequest {
	r.targetBlock = &targetBlock
	return r
}

func (r ApiGetRawBlockProofRequest) Execute() (*GetRawBlockProof200Response, *http.Response, error) {
	return r.ApiService.GetRawBlockProofExecute(r)
}

/*
GetRawBlockProof Method for GetRawBlockProof

Get raw block proof

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRawBlockProofRequest
*/
func (a *LiteServerAPIService) GetRawBlockProof(ctx context.Context) ApiGetRawBlockProofRequest {
	return ApiGetRawBlockProofRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRawBlockProof200Response
func (a *LiteServerAPIService) GetRawBlockProofExecute(r ApiGetRawBlockProofRequest) (*GetRawBlockProof200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawBlockProof200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawBlockProof")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_block_proof"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.knownBlock == nil {
		return localVarReturnValue, nil, reportError("knownBlock is required and must be specified")
	}
	if r.mode == nil {
		return localVarReturnValue, nil, reportError("mode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "known_block", r.knownBlock, "")
	if r.targetBlock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_block", r.targetBlock, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawBlockchainBlockRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	blockId string
}

func (r ApiGetRawBlockchainBlockRequest) Execute() (*GetRawBlockchainBlock200Response, *http.Response, error) {
	return r.ApiService.GetRawBlockchainBlockExecute(r)
}

/*
GetRawBlockchainBlock Method for GetRawBlockchainBlock

Get raw blockchain block

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
 @return ApiGetRawBlockchainBlockRequest
*/
func (a *LiteServerAPIService) GetRawBlockchainBlock(ctx context.Context, blockId string) ApiGetRawBlockchainBlockRequest {
	return ApiGetRawBlockchainBlockRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return GetRawBlockchainBlock200Response
func (a *LiteServerAPIService) GetRawBlockchainBlockExecute(r ApiGetRawBlockchainBlockRequest) (*GetRawBlockchainBlock200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawBlockchainBlock200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawBlockchainBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_block/{block_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_id"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawBlockchainBlockHeaderRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	blockId string
	mode *int32
}

// mode
func (r ApiGetRawBlockchainBlockHeaderRequest) Mode(mode int32) ApiGetRawBlockchainBlockHeaderRequest {
	r.mode = &mode
	return r
}

func (r ApiGetRawBlockchainBlockHeaderRequest) Execute() (*GetRawBlockchainBlockHeader200Response, *http.Response, error) {
	return r.ApiService.GetRawBlockchainBlockHeaderExecute(r)
}

/*
GetRawBlockchainBlockHeader Method for GetRawBlockchainBlockHeader

Get raw blockchain block header

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
 @return ApiGetRawBlockchainBlockHeaderRequest
*/
func (a *LiteServerAPIService) GetRawBlockchainBlockHeader(ctx context.Context, blockId string) ApiGetRawBlockchainBlockHeaderRequest {
	return ApiGetRawBlockchainBlockHeaderRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return GetRawBlockchainBlockHeader200Response
func (a *LiteServerAPIService) GetRawBlockchainBlockHeaderExecute(r ApiGetRawBlockchainBlockHeaderRequest) (*GetRawBlockchainBlockHeader200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawBlockchainBlockHeader200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawBlockchainBlockHeader")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_block_header/{block_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_id"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mode == nil {
		return localVarReturnValue, nil, reportError("mode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawBlockchainBlockStateRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	blockId string
}

func (r ApiGetRawBlockchainBlockStateRequest) Execute() (*GetRawBlockchainBlockState200Response, *http.Response, error) {
	return r.ApiService.GetRawBlockchainBlockStateExecute(r)
}

/*
GetRawBlockchainBlockState Method for GetRawBlockchainBlockState

Get raw blockchain block state

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
 @return ApiGetRawBlockchainBlockStateRequest
*/
func (a *LiteServerAPIService) GetRawBlockchainBlockState(ctx context.Context, blockId string) ApiGetRawBlockchainBlockStateRequest {
	return ApiGetRawBlockchainBlockStateRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return GetRawBlockchainBlockState200Response
func (a *LiteServerAPIService) GetRawBlockchainBlockStateExecute(r ApiGetRawBlockchainBlockStateRequest) (*GetRawBlockchainBlockState200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawBlockchainBlockState200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawBlockchainBlockState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_state/{block_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_id"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawConfigRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	blockId string
	mode *int32
}

// mode
func (r ApiGetRawConfigRequest) Mode(mode int32) ApiGetRawConfigRequest {
	r.mode = &mode
	return r
}

func (r ApiGetRawConfigRequest) Execute() (*GetRawConfig200Response, *http.Response, error) {
	return r.ApiService.GetRawConfigExecute(r)
}

/*
GetRawConfig Method for GetRawConfig

Get raw config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
 @return ApiGetRawConfigRequest
*/
func (a *LiteServerAPIService) GetRawConfig(ctx context.Context, blockId string) ApiGetRawConfigRequest {
	return ApiGetRawConfigRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return GetRawConfig200Response
func (a *LiteServerAPIService) GetRawConfigExecute(r ApiGetRawConfigRequest) (*GetRawConfig200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawConfig200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_config_all/{block_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_id"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mode == nil {
		return localVarReturnValue, nil, reportError("mode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawListBlockTransactionsRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	blockId string
	mode *int32
	count *int32
	accountId *string
	lt *int64
}

// mode
func (r ApiGetRawListBlockTransactionsRequest) Mode(mode int32) ApiGetRawListBlockTransactionsRequest {
	r.mode = &mode
	return r
}

// count
func (r ApiGetRawListBlockTransactionsRequest) Count(count int32) ApiGetRawListBlockTransactionsRequest {
	r.count = &count
	return r
}

// account ID
func (r ApiGetRawListBlockTransactionsRequest) AccountId(accountId string) ApiGetRawListBlockTransactionsRequest {
	r.accountId = &accountId
	return r
}

// lt
func (r ApiGetRawListBlockTransactionsRequest) Lt(lt int64) ApiGetRawListBlockTransactionsRequest {
	r.lt = &lt
	return r
}

func (r ApiGetRawListBlockTransactionsRequest) Execute() (*GetRawListBlockTransactions200Response, *http.Response, error) {
	return r.ApiService.GetRawListBlockTransactionsExecute(r)
}

/*
GetRawListBlockTransactions Method for GetRawListBlockTransactions

Get raw list block transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
 @return ApiGetRawListBlockTransactionsRequest
*/
func (a *LiteServerAPIService) GetRawListBlockTransactions(ctx context.Context, blockId string) ApiGetRawListBlockTransactionsRequest {
	return ApiGetRawListBlockTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return GetRawListBlockTransactions200Response
func (a *LiteServerAPIService) GetRawListBlockTransactionsExecute(r ApiGetRawListBlockTransactionsRequest) (*GetRawListBlockTransactions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawListBlockTransactions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawListBlockTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/list_block_transactions/{block_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_id"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mode == nil {
		return localVarReturnValue, nil, reportError("mode is required and must be specified")
	}
	if r.count == nil {
		return localVarReturnValue, nil, reportError("count is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "")
	}
	if r.lt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lt", r.lt, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawMasterchainInfoRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
}

func (r ApiGetRawMasterchainInfoRequest) Execute() (*GetRawMasterchainInfo200Response, *http.Response, error) {
	return r.ApiService.GetRawMasterchainInfoExecute(r)
}

/*
GetRawMasterchainInfo Method for GetRawMasterchainInfo

Get raw masterchain info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRawMasterchainInfoRequest
*/
func (a *LiteServerAPIService) GetRawMasterchainInfo(ctx context.Context) ApiGetRawMasterchainInfoRequest {
	return ApiGetRawMasterchainInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRawMasterchainInfo200Response
func (a *LiteServerAPIService) GetRawMasterchainInfoExecute(r ApiGetRawMasterchainInfoRequest) (*GetRawMasterchainInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawMasterchainInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawMasterchainInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_masterchain_info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawMasterchainInfoExtRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	mode *int32
}

// mode
func (r ApiGetRawMasterchainInfoExtRequest) Mode(mode int32) ApiGetRawMasterchainInfoExtRequest {
	r.mode = &mode
	return r
}

func (r ApiGetRawMasterchainInfoExtRequest) Execute() (*GetRawMasterchainInfoExt200Response, *http.Response, error) {
	return r.ApiService.GetRawMasterchainInfoExtExecute(r)
}

/*
GetRawMasterchainInfoExt Method for GetRawMasterchainInfoExt

Get raw masterchain info ext

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRawMasterchainInfoExtRequest
*/
func (a *LiteServerAPIService) GetRawMasterchainInfoExt(ctx context.Context) ApiGetRawMasterchainInfoExtRequest {
	return ApiGetRawMasterchainInfoExtRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRawMasterchainInfoExt200Response
func (a *LiteServerAPIService) GetRawMasterchainInfoExtExecute(r ApiGetRawMasterchainInfoExtRequest) (*GetRawMasterchainInfoExt200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawMasterchainInfoExt200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawMasterchainInfoExt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_masterchain_info_ext"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mode == nil {
		return localVarReturnValue, nil, reportError("mode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawShardBlockProofRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	blockId string
}

func (r ApiGetRawShardBlockProofRequest) Execute() (*GetRawShardBlockProof200Response, *http.Response, error) {
	return r.ApiService.GetRawShardBlockProofExecute(r)
}

/*
GetRawShardBlockProof Method for GetRawShardBlockProof

Get raw shard block proof

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
 @return ApiGetRawShardBlockProofRequest
*/
func (a *LiteServerAPIService) GetRawShardBlockProof(ctx context.Context, blockId string) ApiGetRawShardBlockProofRequest {
	return ApiGetRawShardBlockProofRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return GetRawShardBlockProof200Response
func (a *LiteServerAPIService) GetRawShardBlockProofExecute(r ApiGetRawShardBlockProofRequest) (*GetRawShardBlockProof200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawShardBlockProof200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawShardBlockProof")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_shard_block_proof/{block_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_id"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawShardInfoRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	blockId string
	workchain *int32
	shard *int64
	exact *bool
}

// workchain
func (r ApiGetRawShardInfoRequest) Workchain(workchain int32) ApiGetRawShardInfoRequest {
	r.workchain = &workchain
	return r
}

// shard
func (r ApiGetRawShardInfoRequest) Shard(shard int64) ApiGetRawShardInfoRequest {
	r.shard = &shard
	return r
}

// exact
func (r ApiGetRawShardInfoRequest) Exact(exact bool) ApiGetRawShardInfoRequest {
	r.exact = &exact
	return r
}

func (r ApiGetRawShardInfoRequest) Execute() (*GetRawShardInfo200Response, *http.Response, error) {
	return r.ApiService.GetRawShardInfoExecute(r)
}

/*
GetRawShardInfo Method for GetRawShardInfo

Get raw shard info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockId block ID: (workchain,shard,seqno,root_hash,file_hash)
 @return ApiGetRawShardInfoRequest
*/
func (a *LiteServerAPIService) GetRawShardInfo(ctx context.Context, blockId string) ApiGetRawShardInfoRequest {
	return ApiGetRawShardInfoRequest{
		ApiService: a,
		ctx: ctx,
		blockId: blockId,
	}
}

// Execute executes the request
//  @return GetRawShardInfo200Response
func (a *LiteServerAPIService) GetRawShardInfoExecute(r ApiGetRawShardInfoRequest) (*GetRawShardInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawShardInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawShardInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_shard_info/{block_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_id"+"}", url.PathEscape(parameterValueToString(r.blockId, "blockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.workchain == nil {
		return localVarReturnValue, nil, reportError("workchain is required and must be specified")
	}
	if r.shard == nil {
		return localVarReturnValue, nil, reportError("shard is required and must be specified")
	}
	if r.exact == nil {
		return localVarReturnValue, nil, reportError("exact is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "workchain", r.workchain, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "shard", r.shard, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "exact", r.exact, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawTimeRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
}

func (r ApiGetRawTimeRequest) Execute() (*GetRawTime200Response, *http.Response, error) {
	return r.ApiService.GetRawTimeExecute(r)
}

/*
GetRawTime Method for GetRawTime

Get raw time

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRawTimeRequest
*/
func (a *LiteServerAPIService) GetRawTime(ctx context.Context) ApiGetRawTimeRequest {
	return ApiGetRawTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRawTime200Response
func (a *LiteServerAPIService) GetRawTimeExecute(r ApiGetRawTimeRequest) (*GetRawTime200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawTime200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawTransactionsRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	accountId string
	count *int32
	lt *int64
	hash *string
}

// count
func (r ApiGetRawTransactionsRequest) Count(count int32) ApiGetRawTransactionsRequest {
	r.count = &count
	return r
}

// lt
func (r ApiGetRawTransactionsRequest) Lt(lt int64) ApiGetRawTransactionsRequest {
	r.lt = &lt
	return r
}

// hash
func (r ApiGetRawTransactionsRequest) Hash(hash string) ApiGetRawTransactionsRequest {
	r.hash = &hash
	return r
}

func (r ApiGetRawTransactionsRequest) Execute() (*GetRawTransactions200Response, *http.Response, error) {
	return r.ApiService.GetRawTransactionsExecute(r)
}

/*
GetRawTransactions Method for GetRawTransactions

Get raw transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId account ID
 @return ApiGetRawTransactionsRequest
*/
func (a *LiteServerAPIService) GetRawTransactions(ctx context.Context, accountId string) ApiGetRawTransactionsRequest {
	return ApiGetRawTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return GetRawTransactions200Response
func (a *LiteServerAPIService) GetRawTransactionsExecute(r ApiGetRawTransactionsRequest) (*GetRawTransactions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawTransactions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.GetRawTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/get_transactions/{account_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.count == nil {
		return localVarReturnValue, nil, reportError("count is required and must be specified")
	}
	if r.lt == nil {
		return localVarReturnValue, nil, reportError("lt is required and must be specified")
	}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "lt", r.lt, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "hash", r.hash, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendRawMessageRequest struct {
	ctx context.Context
	ApiService *LiteServerAPIService
	sendRawMessageRequest *SendRawMessageRequest
}

// Data that is expected
func (r ApiSendRawMessageRequest) SendRawMessageRequest(sendRawMessageRequest SendRawMessageRequest) ApiSendRawMessageRequest {
	r.sendRawMessageRequest = &sendRawMessageRequest
	return r
}

func (r ApiSendRawMessageRequest) Execute() (*SendRawMessage200Response, *http.Response, error) {
	return r.ApiService.SendRawMessageExecute(r)
}

/*
SendRawMessage Method for SendRawMessage

Send raw message to blockchain

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendRawMessageRequest
*/
func (a *LiteServerAPIService) SendRawMessage(ctx context.Context) ApiSendRawMessageRequest {
	return ApiSendRawMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SendRawMessage200Response
func (a *LiteServerAPIService) SendRawMessageExecute(r ApiSendRawMessageRequest) (*SendRawMessage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendRawMessage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiteServerAPIService.SendRawMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/liteserver/send_message"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sendRawMessageRequest == nil {
		return localVarReturnValue, nil, reportError("sendRawMessageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendRawMessageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v StatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
