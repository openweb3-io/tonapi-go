/*
REST api to TON blockchain explorer

Provide access to indexed TON blockchain

API version: 2.0.0
Contact: support@tonkeeper.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tonapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the Risk type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Risk{}

// Risk Risk specifies assets that could be lost if a message would be sent to a malicious smart contract. It makes sense to understand the risk BEFORE sending a message to the blockchain.
type Risk struct {
	// transfer all the remaining balance of the wallet.
	TransferAllRemainingBalance bool `json:"transfer_all_remaining_balance"`
	Ton int64 `json:"ton"`
	Jettons []JettonQuantity `json:"jettons"`
	Nfts []NftItem `json:"nfts"`
}

type _Risk Risk

// NewRisk instantiates a new Risk object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewRisk(transferAllRemainingBalance bool, ton int64, jettons []JettonQuantity, nfts []NftItem) *Risk {
	this := Risk{}
	this.TransferAllRemainingBalance = transferAllRemainingBalance
	this.Ton = ton
	this.Jettons = jettons
	this.Nfts = nfts
	return &this
}

// NewRiskWithDefaults instantiates a new Risk object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewRiskWithDefaults() *Risk {
	this := Risk{}
	return &this
}

// GetTransferAllRemainingBalance returns the TransferAllRemainingBalance field value
func (o *Risk) GetTransferAllRemainingBalance() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.TransferAllRemainingBalance
}

// GetTransferAllRemainingBalanceOk returns a tuple with the TransferAllRemainingBalance field value
// and a boolean to check if the value has been set.
func (o *Risk) GetTransferAllRemainingBalanceOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.TransferAllRemainingBalance, true
}

// SetTransferAllRemainingBalance sets field value
func (o *Risk) SetTransferAllRemainingBalance(v bool) {
	o.TransferAllRemainingBalance = v
}

// GetTon returns the Ton field value
func (o *Risk) GetTon() int64 {
	if o == nil {
		var ret int64
		return ret
	}

	return o.Ton
}

// GetTonOk returns a tuple with the Ton field value
// and a boolean to check if the value has been set.
func (o *Risk) GetTonOk() (*int64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Ton, true
}

// SetTon sets field value
func (o *Risk) SetTon(v int64) {
	o.Ton = v
}

// GetJettons returns the Jettons field value
func (o *Risk) GetJettons() []JettonQuantity {
	if o == nil {
		var ret []JettonQuantity
		return ret
	}

	return o.Jettons
}

// GetJettonsOk returns a tuple with the Jettons field value
// and a boolean to check if the value has been set.
func (o *Risk) GetJettonsOk() ([]JettonQuantity, bool) {
	if o == nil {
		return nil, false
	}
	return o.Jettons, true
}

// SetJettons sets field value
func (o *Risk) SetJettons(v []JettonQuantity) {
	o.Jettons = v
}

// GetNfts returns the Nfts field value
func (o *Risk) GetNfts() []NftItem {
	if o == nil {
		var ret []NftItem
		return ret
	}

	return o.Nfts
}

// GetNftsOk returns a tuple with the Nfts field value
// and a boolean to check if the value has been set.
func (o *Risk) GetNftsOk() ([]NftItem, bool) {
	if o == nil {
		return nil, false
	}
	return o.Nfts, true
}

// SetNfts sets field value
func (o *Risk) SetNfts(v []NftItem) {
	o.Nfts = v
}

func (o Risk) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o Risk) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["transfer_all_remaining_balance"] = o.TransferAllRemainingBalance
	toSerialize["ton"] = o.Ton
	toSerialize["jettons"] = o.Jettons
	toSerialize["nfts"] = o.Nfts
	return toSerialize, nil
}

func (o *Risk) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"transfer_all_remaining_balance",
		"ton",
		"jettons",
		"nfts",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varRisk := _Risk{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varRisk)

	if err != nil {
		return err
	}

	*o = Risk(varRisk)

	return err
}

type NullableRisk struct {
	value *Risk
	isSet bool
}

func (v NullableRisk) Get() *Risk {
	return v.value
}

func (v *NullableRisk) Set(val *Risk) {
	v.value = val
	v.isSet = true
}

func (v NullableRisk) IsSet() bool {
	return v.isSet
}

func (v *NullableRisk) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableRisk(val *Risk) *NullableRisk {
	return &NullableRisk{value: val, isSet: true}
}

func (v NullableRisk) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableRisk) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


